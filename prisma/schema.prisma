// frontend/prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Main Persona record: simple fields + arrays/JSON for flexible traits.
/// Taxonomy-managed links are stored via PersonaTaxonomy (many-to-many).
model Persona {
  id              String   @id @default(uuid())
  name            String
  nickname        String? // new: optional nickname
  ageGroup        String? // select
  genderIdentity  String? // select/free text
  pronouns        String?
  profession      String? // free text job title
  temperament     String? // select
  confidence      Int? // 1..10
  verbosity       Int? // 1..10 slider
  tone            String? // select
  accentNote      String? // free text override
  quirks          String[] // text[]
  vocabularyStyle String? // select
  debateApproach  String[] // multi-select
  conflictStyle   String? // select
  voiceProvider   String? // select
  voiceStyle      Json? // { pitch, speed, gendered }
  emotionMap      String[] // multi-select
  avatarUrl       String? // url to AI generated avatar based on persona properties
  description     String? @db.Text // AI-authored persona profile; regenerated on save
  createdAt       DateTime @default(now())
  updatedAt       DateTime @default(now()) @updatedAt // ✅ auto-updated whenever record changes

  taxonomies PersonaTaxonomy[]

  // ✅ NEW: opposite side of DebateParticipant.persona
  debateParticipants DebateParticipant[]
}

model Taxonomy {
  id          String            @id @default(uuid())
  category    String
  term        String
  slug        String?
  isActive    Boolean           @default(true)
  description String            @default("")   // NEW field
  createdAt   DateTime          @default(now())
  personas    PersonaTaxonomy[]


  // --- begin: new fields for category linkage ---
  categoryId  String?
  taxonomyCategory  TaxonomyCategory? @relation(fields: [categoryId], references: [id], onDelete: SetNull)


  @@unique([category, term], name: "category_term")
  @@index([category])
}

model TaxonomyCategory {
  id          String   @id @default(cuid())
  key         String   @unique
  fullName    String
  description String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  taxonomy    Taxonomy[]
}

model PersonaTaxonomy {
  personaId  String
  taxonomyId String
  persona    Persona  @relation(fields: [personaId], references: [id], onDelete: Cascade)
  taxonomy   Taxonomy @relation(fields: [taxonomyId], references: [id], onDelete: Cascade)

  @@id([personaId, taxonomyId], name: "personaId_taxonomyId")
  @@index([taxonomyId])
}

model Debate {
  id          String   @id @default(uuid())
  title       String
  topic       String
  description String? // NEW: long-form explanation
  format      String   @default("structured")
  status      String   @default("DRAFT")
  config      Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  participants DebateParticipant[]
}

model DebateParticipant {
  id          String  @id @default(uuid())
  debateId    String
  personaId   String
  role        String // "MODERATOR" | "DEBATER" | "HOST" | "GUEST"
  orderIndex  Int     @default(0) // speaking/display order within the debate
  displayName String?
  voiceId     String?
  meta        Json?

  debate  Debate  @relation(fields: [debateId], references: [id], onDelete: Cascade)
  persona Persona @relation(fields: [personaId], references: [id])

  @@index([debateId])
  @@index([personaId])
  @@index([debateId, orderIndex])
}